---
title: "02-R_Analysis"
output: html_document
date: "2025-10-07"
editor_options: 
  markdown: 
    wrap: 72
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, message=FALSE, warning=FALSE, results='hide'}
library(fs)
library(readr)
library(ggplot2)
library(knitr)
library(dplyr)
library(tidyr)
```

## Reading in Our Data

```{r}
data <- read_csv(path_wd("..", "data", "processed", "odi_bbb_recent.csv"))
```

## Initial Analysis

```{r}
glimpse(data)
```

```{r}
dim(data)

```

```{r}
# Count unique matches
n_matches <- data %>% summarise(n_matches = n_distinct(match_id))
n_matches
```

```{r}
# Check missing values by column
colSums(is.na(data))
```
The majority of these NAs can be replaced with 0. For example, where an NA is in wickets represents there being no wickets taken in that ball. 

## Time/Event Series Structure

The ball-by-ball (bbb) cricket data is inherently an event sequence
structure which we can index by balls or overs. In this section I aim to
demonstrate that structure and investigate any interesting features. Bukiet [5] has an interesting approach to trying to model this time dependent structure of cricket by using Markov Chains. 

```{r}
data %>%
  mutate(over = ceiling(ball)) %>%
  group_by(match_id, innings, over) %>%
  summarise(over_runs = sum(runs_off_bat + extras, na.rm = TRUE), .groups = "drop") %>%
  group_by(innings, over) %>%
  summarise(avg_runs = mean(over_runs, na.rm = TRUE), .groups = "drop") %>%
  ggplot(aes(x = over, y = avg_runs, color = factor(innings))) +
  geom_line(size = 1) +
  geom_vline(xintercept = 10, linetype = "dotted", color = "red", size = 1) +
  geom_vline(xintercept = 40, linetype = "dotted", color = "red", size = 1) +
  labs(
    title = "Average Runs per Over by Innings",
    x = "Over", 
    y = "Average Runs", 
    color = "Innings"
  ) +
  theme_minimal()



```

Here we can clearly see the event series structure. There are 3 sections
in an ODI cricket game, referring to the restrictions placed on the
fielding team. In the first 'Powerplay' the batting team have an
advantage, making it easier for them to get boundaries (4s and 6s). We
can see this by the slightly increased average runs per over for the
first 10 overs (once they get their eye in). We can also see that the
average runs per over generally increases with time. At 40 overs the
second 'Powerplay' occurs which gives the bowling team the advantage.
This period is sometimes referred to as the death and despite the fact
that the bowling team has an advantage, the run rate steeply increases,
particularly in the first innings. This is because they are taking more
risks to attempt to set a high a target for the other team as possible.
It also increases in the second innings but less so as they can afford
to be more conservative as they know what goal they need to reach.

### Risk taking throughout the match

One way we can attempt to quantify risk taking/ shifts in strategy is by
looking at the distribution of boundaries throughout the game. This
demonstrates the underlying structure of the previous plot, a higher
proportion of boundaries in the first and last 10 overs.

```{r}

data %>%
  mutate(over = ceiling(ball)) %>%
  group_by(over) %>%
  summarise(
    total_balls = n(),
    boundaries = sum(runs_off_bat %in% c(4, 6), na.rm = TRUE)
  ) %>%
  mutate(boundary_rate = boundaries / total_balls) %>%
  ggplot(aes(x = over, y = boundary_rate)) +
  geom_vline(xintercept = 10, linetype = "dashed", color = "red", size = 1) +
  geom_vline(xintercept = 40, linetype = "dashed", color = "red", size = 1) +
  geom_col(fill = "steelblue") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(title = "Proportion of Balls that are Boundaries by Over",
       x = "Over",
       y = "Boundary Proportion") +
  theme_minimal()



```

Another way to see that this is 'risky' is by looking at the
distribution of dismissals. Here we can see that the you are slightly
more likely to be dismissed in the first 10 overs, due to the risk
taking, however this is offset by having your best batters bat first. In
the last 10 overs it increases massively as we have worse batters taking
more risks.

```{r}
wickets_data <- data %>%
  filter(!is.na(player_dismissed)) %>%
  mutate(over = ceiling(ball))

ggplot(wickets_data, aes(x = over)) +
  geom_histogram(aes(y = after_stat(density)),
                 binwidth = 1,
                 fill = "red", color = "black", alpha = 0.6) +
  labs(title = "Density of Wickets by Over",
       x = "Over", y = "Density of Wickets") +
  geom_vline(xintercept = c(10, 40), linetype = "dotted", color = "blue") +
  theme_minimal()
```

Lets combine what we have learnt so far and see if we can see it to an
individual game.

One way to visualise the event series popularised by ESPNcricinfo [2] is
the 'worm chart'.

```{r}
data <- data %>%
  mutate(over = ceiling(ball))

data <- data %>%
  mutate(total_runs = runs_off_bat + ifelse(is.na(extras), 0, extras))

worm_data <- data %>%
  group_by(match_id, innings, over) %>%
  summarise(runs = sum(total_runs, na.rm = TRUE), .groups = "drop") %>%
  group_by(match_id, innings) %>%
  mutate(cum_runs = cumsum(runs))



ggplot(filter(worm_data, match_id == 749781),
       aes(x = over, y = cum_runs, colour = factor(innings))) +
  geom_line(size = 1) +
  labs(title = "Worm Chart - New Zealand vs Sri Lanka",
       x = "Over", y = "Cumulative Runs",
       colour = "Innings")


```

Here we can see that the team batting first's (Sri Lanka) run rate
(gradient) stays fairly consistent until the last 10 overs where they
try to run up their score and the line steepens. For New Zealand, they
take advantage of the Powerplay in the first 10 overs and then can play
conservatively for the next 30 Overs winning with 6 Overs to spare. Lets
see if this is reflected in the distribution of wickets. We would expect
Sri Lanka to pick up a lot of wickets in the last 10 overs as they play
riskier.

```{r}
wickets_data <- data %>%
  filter(!is.na(player_dismissed)) %>%   # keep only rows where a wicket fell
  group_by(match_id, innings, over) %>%
  summarise(wickets = n(), .groups = "drop") %>%   # how many wickets in that over
  left_join(worm_data, by = c("match_id", "innings", "over"))

ggplot(filter(worm_data, match_id == 749781),
       aes(x = over, y = cum_runs, colour = factor(innings))) +
  geom_line(size = 1) +
  geom_point(data = filter(wickets_data, match_id == 749781),
             aes(x = over, y = cum_runs, colour = factor(innings)),
             shape = 1, size = 3, stroke = 1.2) +
  labs(title = "Worm Chart - New Zealand vs Sri Lanka",
       x = "Over", y = "Cumulative Runs",
       colour = "Innings") +
  theme_minimal()

```

We do indeed see increased frequency of wickets in the last 10 overs for
Sri Lanka. We can also see that any plateaus of our lines (ie no runs
scored), usually coincides with a wicket (a player being dismissed).
This might suggest a bowler being on a hot streak.

## Team Performance Analysis

This analysis is to get a basic understanding of which teams generally
perform than others. As these metrics are on different scales (runs have
mean \~220 when wickets have an average of \~7) we must standardise
these values so not all metrics are the same colour in their respective
column. The way we will standardise is by subtracting the mean and
dividing by the standard deviation. We must also reverse the colours for
the wickets lost column, as in this case the less wickets lost the
better.

Here I have chosen to do green is 'better' and red is 'worse', so if say
a team scores more runs than the average, their cell will be a darker
green. The idea here is to have a look at which teams are better and
where - a team that has a green row is typically good, and a team that
has a red row is pretty bad.

```{r}
team_performance <- data %>% #make data set
  group_by(match_id, innings, batting_team) %>%
  summarise(runs = sum(runs_off_bat),wickets = sum(!is.na(player_dismissed)),boundaries = sum(runs_off_bat %in% c(4, 6)),.groups = "drop") %>%
  group_by(batting_team) %>%
  summarise(avgruns = mean(runs),avgwickets = mean(wickets),avgboundaries = mean(boundaries),n_innings = n(),.groups = "drop")

team_heatmap_data <- team_performance %>%
  select(batting_team, avgruns, avgwickets, avgboundaries) %>%
  pivot_longer(cols = c(avgruns, avgwickets, avgboundaries),names_to = "metric",values_to = "value")
```

```{r}
team_heatmap_data <- team_heatmap_data %>%
  group_by(metric) %>%
  mutate(standardized_value = if_else(metric == "avgwickets", -(value - mean(value))/sd(value),(value - mean(value)) / sd(value))) %>% #standardise metric by subtracting mean and dividing by standard deviation
  ungroup() #reverse for wickets as less wickets is better

ggplot(team_heatmap_data, aes(x = metric, y = batting_team, fill = standardized_value)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%.1f", value)), color = "black", size = 3) +
  scale_fill_gradient2(low = "red", mid = "white", high = "darkgreen", midpoint = 0) +
  labs(title = "Average Team Performance Across Key Metrics",subtitle = "Green = better performance, Red = worse performance (relative to average)",x = "Performance Metric",y = "Team",fill = "Standardized\nValue") +
  scale_x_discrete(labels = c("avgboundaries" = "Boundaries","avgruns" = "Runs","avgwickets" = "Wickets Lost"))
```

This plot is to have a look at which teams perform better than others.
Can see the strongest teams are England, India and Australia, closely
followed by South Africa. The worst team in terms of the metrics on the
chart is Papua New Guinea, who have the worst performance in each
metric.

# Match Momentum Analysis

This plot is to have a look at which teams perform better than others.
Can see the strongest teams are England, India and Australia, closely
followed by South Africa. The worst team in terms of the metrics on the
chart is Papua New Guinea, who have the worst performance in each
metric.

## Scoring Streaks and Momentum

We now look into momentum. If a team scores well in one over, this is
asking the question will that carry on into the next.

After looking online, I see generally 7-9 runs in an over is a good
over. We can confirm this as if a batting team averages 8 runs in an
over in 50 overs they will end up with 400 runs, being a very good
score. As we are looking at momentum gained after a good over, we will
classify a big over as an over with 10+ runs.

```{r}
over_runs <- data %>% #get runs per over
  group_by(match_id, innings, over) %>%
  summarise(runs_in_over = sum(runs_off_bat),.groups = "drop") %>%
  arrange(match_id, innings, over) %>%
  group_by(match_id, innings) %>%
  mutate(next_over_runs = lead(runs_in_over),prev_over_runs = lag(runs_in_over)) %>%
  ungroup()

scoring_comparison <- over_runs %>% #compare what happens after big overs vs normal overs
  filter(!is.na(next_over_runs)) %>%
  mutate(over_type = case_when(runs_in_over >= 10 ~ "Big Over (10+)",runs_in_over <= 3 ~ "Quiet Over (0-3)",TRUE ~ "Normal Over (4-7)"))
```

```{r}
scoring_comparison %>%
  ggplot(aes(x = over_type, y = next_over_runs, fill = over_type)) +
  geom_boxplot() +
  scale_fill_manual(values = c("Big Over (10+)" = "yellow","Normal Over (4-9)" = "white","Quiet Over (0-3)" = "blue")) +
  labs(title = "Runs in Next Over Based on Current Over Performance",x = "Current Over Type",y = "Runs in Next Over",fill = "Over Type")

```

We can see there is a difference for runs in an over depending on the
past overs run count, which could signal that momentum has an effect,
but could also be explained by a mismatched game (team being much better
than opponent, meaning on average their runs per over would be higher).

## Winning Streaks Across Matches

A natural progression from single match momentum is to analyse momentum
over multiple matches.

For analysis, we are going to prepare a data set arranged in teams, that
will have a binary classification win = 1, lose = 0 and then make a
score for the outcome of the previous 3 or so games. The charts we will
make are win percentage given outcome of last match, and winning
percentage given outcomes of last 3 matches.

```{r}
match_results <- data %>% #getting match results for each team in chronological order
  distinct(match_id, start_date, team1, team2, winner) %>%
  filter(!is.na(winner)) %>% #remove any non-conclusive matches
  arrange(start_date)

team_match_records <- bind_rows(match_results %>% 
    select(match_id, start_date, team = team1, winner),match_results %>% 
    select(match_id, start_date, team = team2, winner)) %>%
  arrange(team, start_date) %>% #so that each row represents each record
  mutate(won = ifelse(team == winner, 1, 0)) #binary win = 1, lose = 0

team_streaks <- team_match_records %>% #calculate score for previous matches
  group_by(team) %>%
  mutate(prev_result = lag(won),prev_2_results= lag(won) + lag(won, 2),prev_3_results= lag(won) + lag(won, 2) + lag(won, 3)) %>%
  filter(!is.na(prev_result)) %>%
  ungroup()

glimpse(team_streaks)
```

As an introduction to multi match momentum, we will first start with the
probability a team wins a game, given the outcome of their previous
game. We do this by setting the

```{r}
team_streaks %>%
  mutate(previous_match = ifelse(prev_result == 1, "Won Last Match", "Lost Last Match")) %>%
  group_by(previous_match) %>%
  summarise(win_rate = mean(won),n = n(),.groups = "drop") %>%
  ggplot(aes(x = previous_match, y = win_rate, fill = previous_match)) +
  geom_col() +
  geom_text(aes(label = sprintf("%.1f%%", win_rate * 100)), size = 5) +
  scale_fill_manual(values = c("Won Last Match" = "green", "Lost Last Match" = "red")) +
  labs(x = "Previous Match Result",y = "Win Rate in Current Match")
```

This plot doesn't seem overly useful to us, as it doesn't really tell us
anything. Looking at the binary 'win match/lose match', every game is
included in this calculation as every game is either won or lost. One
possible interpretation could be that it shows the difference in team
quality, how much better the good teams are compared to the bad ones.
Still, it is a simple easy to understand plot so I thought I may as well
include it.

We can try and improve the plot by extending it to winning probability
given a winning streak. This could be

```{r}
team_streaks %>% #
  filter(!is.na(prev_3_results)) %>%
  mutate(streak = case_when(prev_3_results == 3 ~ "Won last 3",prev_3_results == 0 ~ "Lost last 3",TRUE ~ "Mixed recent form")) %>% #3 wins = 1+1+1=3, 3 losses = 0+0+0=0
  group_by(streak) %>%
  summarise(win_rate = mean(won),n = n(),.groups = "drop") %>%
  ggplot(aes(x = reorder(streak, win_rate), y = win_rate, fill = streak)) +
  geom_col() +
  geom_text(aes(label = sprintf("%.1f%%", win_rate * 100)), vjust = -0.5, size = 4) +
  coord_flip() +
  scale_fill_manual(values = c("Won last 3" = "green", "Mixed recent form" = "yellow","Lost last 3" = "red")) +
  scale_y_continuous(labels = scales::percent, limits = c(0, 0.7)) +
  labs(title = "Win Rate Based on Recent Form (Last 3 Matches)",x = "Recent Form",y = "Win Rate in Current Match")
```

This can be viewed as winning streaks having an effect on winning
probability, and hence supporting the idea that momentum is significant,
though again it could also be interpreted as if a team is on a winning
streak, they may just be a good team who wins more on average. This plot
tells us more than the previous, though it definitely isn't conclusive.

## Powerplay Analysis

Let's take a look at the powerplay - in particular how many boundaries
are scored during the batting powerplay and how many wickets are lost.
The big idea here being that if we were building a model for predicting
match outcome as the game is being played, the powerplay would be a key
indicator of how well a team's innings is going.

```{r, Powerplay boundaries}
powerplay_boundaries <- data %>%
  filter(ball < 10, runs_off_bat %in% c(4, 6)) %>%  # only Powerplay & boundaries
  group_by(match_id, batting_team) %>%
  summarise(boundaries = n(), .groups = "drop")

powerplay_outcome <- data %>%
  distinct(match_id, batting_team, winner) %>%
  mutate(result = ifelse(batting_team == winner, "Won", "Lost"))

powerplay_summary <- powerplay_boundaries %>%
  left_join(powerplay_outcome, by = c("match_id", "batting_team")) %>%
  filter(!is.na(result))

```

```{r}
powerplay_summary %>%
  ggplot(aes(x = boundaries, fill = result)) +
  geom_histogram(position = "identity", alpha = 0.6, bins = 15) +
  scale_fill_manual(values = c("Won" = "green", "Lost" = "red")) +
  labs(title = "Boundaries in Powerplay vs Match Outcome",
       x = "Number of Boundaries in First 10 Overs",
       y = "Number of Innings",
       fill = "Match Result") +
  theme_minimal()

```

This distribution shows very clearly that teams that score more
boundaries in the *batting powerplay* tend to win more matches - the
green distribution shows teams that win matches. Therefore boundaries
during the powerplay is likely to be a useful indicator of which team
will win.

We can also look at the worm plots for the entire powerplay, and
potentially spot trends in winning innings.

Clean the data:
```{r}
odis_bbb_recent <- data %>%
  select(match_id, innings, ball, runs_off_bat, extras, wicket_type, batting_team, winner) %>%
  separate(ball, into = c("over", "ball_"), sep = "\\.", convert = TRUE) %>%
  mutate(
    wicket_type = ifelse(is.na(wicket_type), "", wicket_type),
    legal_ball = ifelse(extras > 0, 0, 1),
    wicket = ifelse(wicket_type == "", 0, 1),
    won_innings = ifelse(batting_team == winner, "Won", "Lost")
    )
```

Seperate into individual innings:
```{r}
match_innings_list <- split(odis_bbb_recent, list(odis_bbb_recent$match_id, odis_bbb_recent$innings))
```

Cumulative sum of runs, wickets and legal deliveries:
```{r}
for (i in seq_along(match_innings_list)) {
  innings <- match_innings_list[[i]] %>%
    mutate(
      ball_count = cumsum(legal_ball),
      run_count = cumsum(runs_off_bat + extras),
      wicket_count = cumsum(wicket)
      ) %>%
    filter(ball_count <= 60)
  match_innings_list[[i]] <- innings
}
```

Plotting all innings:
```{r}
combined_data <- bind_rows(match_innings_list)

ggplot(combined_data %>% filter(!is.na(won_innings)),
       aes(x = ball_count, y = run_count, group = interaction(match_id, innings), colour = won_innings)) +
  geom_line(alpha = 0.3, size = 0.7) +
  scale_colour_manual(values = c("Won" = "black", "Lost" = "red")) +
  labs(x = "Ball number", y = "Cumulative runs", colour = "Result") +
  theme_minimal()
```

While it is possible to observe some level of skew between winning
powerplays and losing ones, the random nature of cricket scoring makes
it difficult to filter out noise. Clearly the extreme innings tell us
that particularly high run rates lead to victory and particularly low
run rates lead to defeat, but beyond that the plot is not helpful.

In an effort to improve on this, we consider how losing wickets in the
powerplay impacts the result of the match.

Heatmap of runs wickets, and expected outcome:
```{r}
heatmap_data <- combined_data %>%
  filter(ball_count == 60) %>%
  mutate(run_bin = floor(run_count / 20) * 20) %>%
  group_by(run_bin, wicket_count) %>%
  summarise(win_prob = mean(won_innings == "Won", na.rm = TRUE)) %>%
  ungroup()

ggplot(heatmap_data, aes(x = run_bin, y = wicket_count, fill = win_prob)) +
  geom_tile(colour = "white") +
  scale_fill_viridis_c(option = "plasma", limits = c(0,1)) +
  labs(
    x = "Runs scored",
    y = "Wickets lost",
    fill = "Win probability"
  ) +
  theme_minimal()
```

This heatmap gives us a much clearer idea of the impact of runs and
wickets in the powerplay. Not only does it provide us with the somewhat
obvious conclusion that scoring more runs is good and losing more
wickets is bad, but it demonstrates a relationship between the two.
According to our data, finishing the powerplay with a score of 75 for
the loss of two wickets gives a team a greater chance of going on to win
the match than finishing the powerplay at 100 for three. This is
interesting because it is not exactly the conclusion one might expect. A
worthwhile extension to this would be to create a "relative value"
function, one that relates wickets and runs in the powerplay more
explicitly.

## Bowling Style Analysis

In this section, we explore how different **bowling styles** affect the
average number of runs conceded per ball. Bowling style is an important
characteristic of a team's bowling attack and may serve as a useful
predictor of match outcomes in later stages of the project.

The plot below shows the average runs per ball for each bowling style in
the dataset. To make patterns clearer, we colour code styles that are
above the overall average in red and those below average in blue. This
gives a quick visual sense of which bowling styles tend to be more or
less economical.

To produce this figure I borrowed ideas from tutorials on producing
advanced plots with ggplot2.[5] We first group the data by bowling style
and calculate the mean runs conceded per ball. We also record the total
number of balls bowled for each style to indicate the sample size.

```{r bowling-style-plot, fig.width=10, fig.height=12}

# Calculate summary statistics by bowling style
bowling_stats <- data %>%
  group_by(bowling_style) %>%
  summarise(
    avg_runs_per_ball = mean(runs_off_bat + coalesce(extras, 0), na.rm = TRUE),
    balls_bowled = n(),
    .groups = "drop"
  ) %>%
  arrange(desc(avg_runs_per_ball))

# Overall average economy across all styles
overall_mean <- mean(bowling_stats$avg_runs_per_ball)

# Plot
p <- ggplot(bowling_stats, aes(x = reorder(bowling_style, avg_runs_per_ball),
                               y = avg_runs_per_ball)) +

  # Horizontal line for overall mean
  geom_hline(yintercept = overall_mean, linetype = "dashed",
             color = "#E74C3C", linewidth = 0.8, alpha = 0.7) +

  # Bars: red if above mean, blue if below
  geom_col(aes(fill = avg_runs_per_ball > overall_mean),
           width = 0.7, show.legend = FALSE) +

  # Value labels on the bars
  geom_text(aes(label = sprintf("%.2f", avg_runs_per_ball)),
            hjust = -0.2, size = 4, color = "#2C3E50", fontface = "bold") +

  # Sample size labels inside bars
  geom_text(aes(label = paste0("n=", balls_bowled)),
            hjust = 1.1, size = 3.2, color = "white", alpha = 0.8) +

  scale_fill_manual(values = c("TRUE" = "#E74C3C", "FALSE" = "#3498DB")) +
  coord_flip(clip = "off") +

  # Expand y-axis to fit labels
  scale_y_continuous(expand = expansion(mult = c(0.02, 0.15)),
                     breaks = seq(0, 2, 0.2)) +

  labs(
    title = "Bowling Economy by Style",
    subtitle = paste0("Overall mean: ", sprintf("%.2f", overall_mean), " runs per ball"),
    x = NULL,
    y = "Average Runs per Ball",
    caption = "Red bars indicate above-average economy; Blue bars indicate below-average.\nn = number of balls bowled"
  ) +

  theme_minimal(base_size = 13) +
  theme(
    plot.title = element_text(face = "bold", size = 17, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 12, color = "#7F8C8D", margin = margin(b = 15)),
    plot.caption = element_text(size = 10, color = "#95A5A6", hjust = 0, margin = margin(t = 15)),
    axis.text.y = element_text(size = 11, color = "#2C3E50", margin = margin(r = 5)),
    axis.text.x = element_text(size = 11, color = "#2C3E50"),
    axis.title.x = element_text(face = "bold", size = 12, margin = margin(t = 10)),
    panel.grid.major.y = element_blank(),
    panel.grid.minor = element_blank(),
    panel.grid.major.x = element_line(color = "#ECF0F1", linewidth = 0.5),
    plot.margin = margin(20, 20, 20, 20)
  )

print(p)
```

Looking at this plot, we can see that bowling styles vary widely in both
average runs conceded and the number of balls bowled. Some styles appear
more economical than others, but this simple comparison does not yet
account for differences in sample size or match context (e.g., bowling
during Powerplays or at the death). These factors will need to be
considered in later analyses to draw stronger conclusions.

## References

[1] A. Kaluarachchi and S. V. Aparna, "CricAI: A classification based
tool to predict the outcome in ODI cricket," 2010 Fifth International
Conference on Information and Automation for Sustainability, Colombo,
Sri Lanka, 2010, pp. 250-25

[2]
[ESPNcricinfo](https://www.espncricinfo.com/series/west-indies-in-england-2025-1448331/england-vs-west-indies-1st-odi-1448343/match-statistics)

[3] [dplyr cheat
sheet](https://posit.co/wp-content/uploads/2022/10/data-transformation.pdf)

[4] [R for Data Science (Wickham &
Grolemund)](https://r4ds.had.co.nz/transform.html)

[5] [R Graph Gallery](https://r-graph-gallery.com/ggplot2-package.html)

[6] Bukiet B, Ovens M. A mathematical modelling approach to one-day cricket batting orders. J Sports Sci Med. 2006
